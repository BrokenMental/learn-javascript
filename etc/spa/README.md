# 싱글 페이지 애플리케이션(SPA)

모바일의 시대가 도래하면서 모바일 환경에 맞춰진 모바일 웹에 대한 필요성이 증가하고, 이에 따른 성능 이슈도 함께 거론되었다. 데스크톱에 비해 성능이 낮은 모바일, 스마트폰을 통해 웹 페이지를 출력하기 위해서는 기존 방식(서버 사이드 렌더링)으로는 성능 문제를 해결할 수 없었고 이에 따라 Single Page Application(SPA)이 등장하게 되었다. **SPA**는 페이지 전체를 요청하는 것이 아니라 최초 한번 페이지 전체를 로딩한 이후부터 필요한 부분만 서버에게 데이터를 받아서 화면에 출력한다. **SPA**는 트래픽을 감소시키고 더 나은 사용자 경험을 제공하였다. 서버는 단지 클라이언트에게 JSON을 반환하는 역할만 하고, HTML을 그리는 역할은 자바스크립트가 담당한다.
**서버 사이드 렌더링**과 **클라이언트 사이드 렌더링**중에서 무엇이 더 좋다 나쁘다를 판단하는 것은 의미가 없다. 현재 작성중인 애플리케이션의 성격에 따라서 유동적으로 사용하면 충분하다.

## SPA 장, 단점

### 장점

- 필요한 부분에 대한 데이터만 서버에 요청하므로 성능 향상의 효과를 얻을 수 있다.
- 네이티브 앱과 동일한 사용자 경험

### 단점

- 초기 구동 속도가 느리다. (대신에, 초기 구동 이후에는 빠르다)
- SEO에 문제가 있다.
    SEO가 필요하지 않은 서비스에 대해서는 문제가 되지 않을 수 있다. 예를 들어 정보의 제공을 위한 웹페이지가 아닌 경우에는 문제가 되지 않는다.

## 용어 정리

### SEO(검색 엔진 최적화)

웹 페이지 검색엔진이 자료를 수집하고 순위를 매기는 방식에 맞게 웹 페이지를 구성해서 검색 결과의 상위에 나올 수 있도록 하는 작업을 말한다.

#### SEO 향상을 위한 자바스크립트 개발 방법

- 모든 페이지,포스트등은 개별적인 URL을 가지도록 한다.
- Ajax를 이용하여 해당 콘텐츠에 접근 할 수 있는 방법도 구축하며, 동시에 Ajax로 콘텐츠가 로드되어도 URL이 변경되도록 한다.
- 콘텐츠의 주소를 설계할때 해시태그(hash tag)는 지양한다.

#### 참고

- [Ajax는 SEO에 악영향을 미치는가?](http://www.linchpinsoft.com/ajax_attack_seo/)

### 서버 사이드 렌더링

요청시마다 새로고침이 일어나며 서버에 전체 페이지(HTML)를 요청을 하는 방식입니다. 컨텐츠의 양이 증가하고 제한된 컴퓨팅 환경을 가지는 스마트폰 사용량이 많아짐에 따라서 전체 페이지를 요청하는 것은 너무나 큰 비용을 초래하게 됩니다. 

> 초기 로딩속도가 빠르고 SEO에 유리하지만, View 변경시 서버에 요청하므로 서버에 부담이 크다

### 클라이언트 사이드 렌더링

사용자 요청에 따라 필요한 부분만 서버 측에서 데이터를 요청하여 화면을 그리기 때문에, 서버 사이드 렌더링에 비해서 사용자 경험과 성능이 뛰어나다. 하지만, 초기 화면을 그리기 위하여 자바스크립트를 읽어드리고, 데이터를 서버에 요청하고, 데이터를 이용하여 HTML을 만들어서 화면에 표시하는데 걸리는 시간이 길어진다. 즉 **초기 구동 속도**가 느리다는 단점이 있다. 대신에 초기 구동을 제외하면 그 다음부터는 속도가 빠르고, 자원을 아낄 수 있다. 또한, 검색 엔진 최적화에 문제가 존재한다. 구글을 제외한 검색 봇은 자바스크립트를 실행하지 못하므로 비어있는 HTML을 수집하게 되어 페이지를 빈 페이지로 인식한다.

> 초기 로딩속도가 느리지만 초기 로딩 이후에는 매우 빨라서 사용자 경험이 뛰어나지만, SEO에 문제가 있다

### URI

![uri](https://user-images.githubusercontent.com/27342882/47597450-d7625600-d9c9-11e8-8713-c0d3d41319c7.JPG)

## 방식

### Link 방식

전통적인 링크 방식은 link tag로 동작하는 기본적인 웹 페이지 동작 방식이다. 브라우저는 서버에게 요청을 하면 서버는 html로 화면을 표시하는데 부족함이 없는 완전한 문서를 응답한다. 이를 서버 사이드 렌더링이라고 부른다. 전체 페이지를 다시 렌더링하므로 새로고침이 일어난다.
이 방식은 자바스크립트가 필요없이 응답된 html만으로 렌더링하기에 각 페이지마다 고유 주소가 존재하며 SEO도 문제가 없다. 단, 요청마다 매번 새로고침을 하기에 사용자 경험을 좋지 않다.

### Ajax 방식

전통적인 링크 방식(Link)는 화면에 표시하는데 부족함이 없는 완전한 문서로 페이지를 렌더링하기에 새로고침이 발생한다. 간단한 웹페이지라면 문제가 없지만, 컨텐츠 중심의 웹 애플리케이션이나 모바일이 우선인 웹 애플리케이션에서는 성능 문제가 있을 수 있다. 이런 단점을 극복하고자 나온 것이 **AJAX**이다. AJAX는 URL을 변경시키지 않으므로 주소창의 주소가 변경되지 않는다. 이는 브라우저의 뒤로가기, 앞으로가기 등의 history 관리가 동작하지 않음을 의미한다. 물론 코드 상의 history.back(), history.go(n) 등도 동작하지 않는다. 새로고침을 클릭하면 주소창의 주소가 변경되지 않기 때문에 언제나 첫페이지가 다시 로딩된다. 하나의 주소로 동작하는 AJAX 방식은 SEO 이슈에서도 자유로울 수 없다.

### Hash 방식

Ajax 방식은 불 필요한 리소스를 방지하므로 성능 향상과 사용자 경험 향상에 도움이 되지만, **history** 관리가 되지 않는 단점이 있다. 이를 보완한 방법이 **Hash 방식**이다. Hash 방식은 URI의 fragment identifier(#service)의 고유 기능인 앵커(anchor)를 사용한다.
위 예제를 살펴보면 link tag의 href 어트리뷰트에 hash를 사용하고 있다. 즉, 내비게이션이 클릭되면 hash가 추가된 URI가 주소창에 표시된다. 단, URL이 동일한 상태에서 hash가 변경되면 브라우저는 서버에 어떠한 요청도 하지 않는다. 즉, hash는 변경되어도 서버에 새로운 요청을 보내지 않으며 따라서 페이지가 갱신되지 않는다. hash는 요청을 위한 것이 아니라 fragment identifier(#service)의 고유 기능인 앵커(anchor)로 웹페이지 내부에서 이동을 위한 것이기 때문이다.

또한 hash 방식은 서버에 새로운 요청을 보내지 않으며 따라서 페이지가 갱신되지 않지만 페이지마다 고유의 논리적 URL이 존재하므로 history 관리에 아무런 문제가 없다.

내비게이션을 클릭하면 uri의 hash가 변경된다. 주소창의 uri가 변경되므로 history 관리가 가능하다. 이때 uri의 hash만 변경되면 서버로 요청을 수행하지 않는다. 따라서 uri의 hash가 변경하면 발생하는 이벤트인 hashchange 이벤트를 사용하여 hash의 변경을 감지하여 필요한 AJAX 요청을 수행한다. hash 방식의 단점은 uri에 불필요한 #이 들어간다는 것이다.

또 다른 문제는 SEO 이슈이다. 크롤러는 검색엔진이 웹사이트의 콘텐츠를 수집하기 위해 HTTP 1.1과 URL 스펙(RFC-2396같은)을 따른다. 이러한 크롤러는 JavaScript를 실행시키지 않기 때문에 hash 방식으로 만들어진 사이트의 콘텐츠를 수집할 수 없다. 구글은 해시뱅을 일반 URL을 변경시켜 이 문제를 해결한 것으로 알려지지만 다른 검색 엔진은 hash 방식으로 만들어진 사이트의 콘텐츠를 수집할 수 없다.

### Pjax 방식

hash 방식의 가장 큰 단점은 SEO 이슈이다. 이를 보완한 방법이 HTML5의 Histroy API인 pushState와 popstate 이벤트를 사용한 PJAX 방식이다. pushState와 popstate은 IE 10 이상에서 동작한다.

PJAX 방식은 서버에 새로운 요청을 보내지 않으며 따라서 페이지가 갱신되지 않는다. 하지만 페이지마다 고유의 URL이 존재하므로 history 관리에 아무런 문제가 없다. 또한 hash를 사용하지 않으므로 SEO에도 문제가 없다.

다만, 브라우저의 새로고침 버튼을 클릭하면 예를들어 loclahost:5004/service와 같은 요청이 서버로 전달된다. 이때 서버는 URL에 따라 해당 리소스를 HTML으로 클라이언트에 응답하여야 한다.

#### Pjax 방식은 SPA가 맞는건가?

```javascript
// Server
const express = require('express');
const app = express();
const fs = require('fs');

app.get('/service', (req, res) => {
  res.format({
    // 새로고침에 의한 브라우저 요청
    'text/html': function(){
      res.sendFile(path.join(__dirname + '/public/data/service.html'));
    },
    // AJAX 요청
    'application/json': function(){
      res.send(JSON.parse(fs.readFileSync('./public/data/service.json', 'utf8')));
    },
    'default': function() {
      // log the request and respond with 406
      res.status(406).send('Not Acceptable');
    }
  });
});

app.listen(3000, function () {
  console.log('listening on http//localhost:3000');
});
```

서버에 요청하는 방식은 크게 두가지이다. 일단 Ajax으로 요청하는 방법 그리고 브라우저 자체 요청이 있다. 브라우저 자체 요청을 쉽게 새로고침이라고 보면 된다. 하지만, 예제를 보면서 의아한 것이 **html** 자체를 반환하는 것이다. 이러면 이것을 **SPA**라고 부를 수 있는가?

## 참고 컨텐츠

- [SPA Pure JavaScript with Ajax - Introduction](https://www.youtube.com/watch?v=_1J_f5kUy8w&list=PLI6YNYee-SAgLIubdFS_rXhneDM3DPetN)

- [Single Page Application & Routing](https://poiemaweb.com/js-spa)

- [HTML5 History API](https://developer.mozilla.org/ko/docs/Web/API/History_API)