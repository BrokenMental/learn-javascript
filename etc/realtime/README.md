# 실시간 웹 애플리케이션

웹 페이지의 한계에서 벗어나 실시간으로 상호작용하는 웹 서비스를 만드는 표준 기술인 **WebSocket**. 그리고 다양한 방식의 실시간 웹 기술을 손쉽게 사용할 수 있는 **Socket.io**.

## WebSocket을 사용하기 전에

웹의 역사가 시작되었을 때에는 사용자와의 상호작용은 웹 개발에서 큰 부분을 차지하지 않았다. 그러나 초창기에 연구기관에서 사용하던 웹은 점점 더 일상생활에 파고들었고, PC용 응용 프로그램(Native Application)을 대체할 수 있는 정도까지 되었다. 전형적인 브라우저 렌더링 방식은 HTTP 요청(HTTP Request)에 대한 HTTP 응답(HTTP Response)을 받아서 브라우저의 화면을 깨끗하게 지우고 받은 내용을 새로 표시하는 방식이다. 내용을 지우고 다시 그리면 브라우저의 깜빡임이 생기게 된다. 이러한 깜빡임 없이 원하는 부분만 다시 그리며 실시간으로 사용자와 상호작용하는 방식이 나타나고 사용자와 상호작용하는 웹 서비스를 선호하는 사용자가 증가하면서 RIA(Rich Internet Application) 기술의 발달이 촉진되었다. 상호작용하는 웹 서비스를 위해 숨겨진 프레임(Hidden Frame)을 이용한 방법이나 **Long Polling, Stream** 등 다양한 방법을 사용했다. **그러나 이러한 방식은 브라우저가 HTTP 요청를 보내고 웹 서버가 이 요청에 대한 HTTP 응답를 보내는 단방향 메세지 교환 '규칙'을 변경하지 않고 구현한 방식이다.** 그렇기 때문에 상호작용하는 웹 페이지를 복잡하고 어려운 코드로 구현해야 했다. 보다 쉽게 상호작용하는 웹 페이지를 만들려면 브라우저와 웹 서버 사이에 더 자유로운 양방향 메시지 송수신(bi-directional full-duplex communication)이 필요하다. 그래서 HTML5 표준안의 일부로 WebSocket API(이후 WebSocket)가 등장했다.

### 단방향 메시지가 실시간에 적합하지 않은 이유는 무엇일까?

내가 알고 있는 **HTTP**의 특징은 한번의 연결, 수립으로 데이터 요청, 응답을 한다는 것이다. 이렇게 설계한 이유는 초기의 웹 환경은 대부분 정적인 페이지가 많았기에 연결을 지속하고 있는 것은 **손해**이기 때문이다. 그리고 **무상태**이기에 즉, 요청에 대한 정보를 서버에 지속적으로 저장하고 있지 않기 때문에, 단점을 보완하기 위해서 쿠키나 세션과 같은 기술이 도입된 것으로 알고 있다. 실시간에 적합하지 않은 이유는 매번 요청/응답마다 새롭게 연결을 수립하고 해지하기 때문이라고 생각된다. 실시간 웹 애플리케이션은 지속적으로 데이터가 바뀌는데 그때마다 연결/해체를 하는 것은 실시간 플랫폼에 맞지 않기 때문이다. 그렇다. 애초에 HTTP의 핵심 특징은 실시간성에 적합하지 않다. 

### HTTP를 실시간처럼 작동하게 하는 기술들

- 폴링(Polling) 방식

지속적으로 서버에 요청을 보내고 결과값으로 변경된 부분에 랜더링하는 것입니다. 하지만 이러한 경우 변경된 부분이 없음에도 불구하고 클라이언트는 서버로 불필요한 요청을 계속해서 하게 됩니다. 불필요한 요청을 계속해서 받고 이에 대한 불필요한 결과값을 계속 응답해주는 서버측의 입장에서도 매우 비 효율적이면서 부하가 많이 발생하게 됩니다.

![polling](https://user-images.githubusercontent.com/27342882/47068608-b3fc1600-d227-11e8-92c8-b702f4b41bb1.JPG)

특정 요청에 대해 이벤트(변경사항)가 있거나 없거나 응답을 보낸다. **요청에 대항 서버 부담이 크지 않거나 실시간 메시지 전달이 중요하지 않은 서비스에 적합하다.** 요청 주기를 조절할 수 있지만 요청주기가 길면 실시간성이 떨어지고, 요청 주기가 짧으면 서버 부하와 네트워크 트래픽이 많이 생겨서 성능이 떨어진다.

- 롱폴링(Long Polling) 방식

요청을 주기적으로 보내고 서버가 바로 응답하는 형식이 아니라 **서버가 변경된 정보가 없을때는 클라이언트가 보낸 요청을 대기하고 있다가 어떠한 요청의 변경사항이 있을때** 비로소 그 응답을 보내는 형식으로 동작을 합니다.

![long polling](https://user-images.githubusercontent.com/27342882/47068986-c3c82a00-d228-11e8-8706-170d876b8373.JPG)

**Polling 모델과 차이점은 클라이언트의 요청에 대해 서버에서 이벤트 발생시에만 응답을 준다는 것이다.** Polling 과 Long Polling 의 차이점은 즉 클라이언트 요청에 대한 서버의 대처방식이다. Long Polling은 실시간 메시지 전달이 중요하고 서버의 상태 변경이 빈번히 발생하지 않는 서비스에 적합하다. Polling 방식에 비해 요청/응답 트랜잭션이 덜 하다. 따라서 서버와 네트워크에 부하가 적다.

- 스트리밍(Streaming) 방식

![stream](https://user-images.githubusercontent.com/27342882/47071632-fa08a800-d22e-11e8-8445-84967bf24509.JPG)

Streaming 은 요청후에 연결을 지속하여 계속적인 응답을 받는 것이다. Polling, Long Polling 과 다르게 응답을 받은후 연결을 종료하지 않는다. 서버는 상태변화(이벤트)시 이 스트림을 통해 응답을 지속적으로 보낸다. 이 모델의 경우 요청이 단 한번만 이루어지기 때문에 서버와 네트워크 트래픽에 부하를 덜 준다. 하지만 응답데이터의 시작과 끝을 알수 없기 때문에(스트림이니까) 데이터의 유효성을 체크하는 루틴이 필요하다.


## WebSocket

## 실시간 웹 애플리케이션 키워드

- Ajax
- socket.io
- websocket
- SPA, One Page App